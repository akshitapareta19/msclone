{"ast":null,"code":"import store from '../../store/store';\nimport { setLocalStream, setCallState, callStates, setCallingDialogVisible, setCallerUsername, setCallRejected } from '../../store/actions/callActions';\nimport * as wss from '../wssConnection/wssConnection';\nconst preOfferAnswers = {\n  CALL_ACCEPTED: 'CALL_ACCEPTED',\n  CALL_REJECTED: 'CALL_REJECTED',\n  CALL_NOT_AVAILABLE: 'CALL_NOT_AVAILABLE'\n};\nconst defaultConstrains = {\n  video: true,\n  audio: true\n};\nconst configuration = {\n  iceServers: [{\n    urls: 'stun:stun.l.google.com:13902'\n  }]\n};\nlet connectedUserSocketId;\nlet peerConnection;\nexport const getLocalStream = () => {\n  navigator.mediaDevices.getUserMedia(defaultConstrains).then(stream => {\n    store.dispatch(setLocalStream(stream));\n    store.dispatch(setCallState(callStates.CALL_AVAILABLE));\n    createPeerConnection();\n  }).catch(err => {\n    console.log('error occured when trying to get an access to get local stream');\n    console.log(err);\n  });\n};\n\nconst createPeerConnection = () => {\n  peerConnection = new RTCPeerConnection(configuration);\n  const localStream = store.getState().call.localStream;\n\n  for (const track of localStream.getTrack()) {\n    peerConnection.addTrack(track, localStream);\n  }\n\n  peerConnection.ontrack = ({\n    streams: [stream]\n  }) => {// dispatch remote stream in our store\n  };\n\n  peerConnection.onicecandidate = event => {// send to connected user our ice candidates\n  };\n};\n\nexport const callToOtherUser = calleeDetails => {\n  connectedUserSocketId = calleeDetails.socketId;\n  store.dispatch(setCallState(callStates.CALL_IN_PROGRESS));\n  store.dispatch(setCallingDialogVisible(true));\n  wss.sendPreOffer({\n    callee: calleeDetails,\n    caller: {\n      username: store.getState().dashboard.username\n    }\n  });\n};\nexport const handlePreOffer = data => {\n  if (checkIfCallIsPossible()) {\n    connectedUserSocketId = data.callerSocketId;\n    store.dispatch(setCallerUsername(data.callerUsername));\n    store.dispatch(setCallState(callStates.CALL_REQUESTED));\n  } else {\n    wss.sendPreOfferAnswer({\n      callerSocketId: data.callerSocketId,\n      answer: preOfferAnswers.CALL_NOT_AVAILABLE\n    });\n  }\n};\nexport const acceptIncomingCallRequest = () => {\n  wss.sendPreOfferAnswer({\n    callerSocketId: connectedUserSocketId,\n    answer: preOfferAnswers.CALL_ACCEPTED\n  });\n};\nexport const rejectIncomingCallRequest = () => {\n  wss.sendPreOfferAnswer({\n    callerSocketId: connectedUserSocketId,\n    answer: preOfferAnswers.CALL_REJECTED\n  });\n  resetCallData();\n};\nexport const handlePreOfferAnswer = data => {\n  store.dispatch(setCallingDialogVisible(false));\n\n  if (data.answer === preOfferAnswers.CALL_ACCEPTED) {// send webRTC offer\n  } else {\n    let rejectionReason;\n\n    if (data.answer === preOfferAnswers.CALL_NOT_AVAILABLE) {\n      rejectionReason = 'Callee is not able to pick up the call right now';\n    } else {\n      rejectionReason = 'Call rejected by the callee';\n    }\n\n    store.dispatch(setCallRejected({\n      rejected: true,\n      reason: rejectionReason\n    }));\n    resetCallData();\n  }\n};\nexport const checkIfCallIsPossible = () => {\n  if (store.getState().call.localStream === null || store.getState().call.callState !== callStates.CALL_AVAILABLE) {\n    return false;\n  } else {\n    return true;\n  }\n};\nexport const resetCallData = () => {\n  connectedUserSocketId = null;\n  store.dispatch(setCallState(callStates.CALL_AVAILABLE));\n};","map":{"version":3,"sources":["C:/Users/akshi/OneDrive/Documents/Desktop/msteams/msteams-frontend/src/utils/webRTC/webRTCHandler.js"],"names":["store","setLocalStream","setCallState","callStates","setCallingDialogVisible","setCallerUsername","setCallRejected","wss","preOfferAnswers","CALL_ACCEPTED","CALL_REJECTED","CALL_NOT_AVAILABLE","defaultConstrains","video","audio","configuration","iceServers","urls","connectedUserSocketId","peerConnection","getLocalStream","navigator","mediaDevices","getUserMedia","then","stream","dispatch","CALL_AVAILABLE","createPeerConnection","catch","err","console","log","RTCPeerConnection","localStream","getState","call","track","getTrack","addTrack","ontrack","streams","onicecandidate","event","callToOtherUser","calleeDetails","socketId","CALL_IN_PROGRESS","sendPreOffer","callee","caller","username","dashboard","handlePreOffer","data","checkIfCallIsPossible","callerSocketId","callerUsername","CALL_REQUESTED","sendPreOfferAnswer","answer","acceptIncomingCallRequest","rejectIncomingCallRequest","resetCallData","handlePreOfferAnswer","rejectionReason","rejected","reason","callState"],"mappings":"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","sourcesContent":["import store from '../../store/store';\r\nimport { setLocalStream, setCallState, callStates, setCallingDialogVisible, setCallerUsername, setCallRejected } from '../../store/actions/callActions';\r\nimport * as wss from '../wssConnection/wssConnection';\r\n\r\nconst preOfferAnswers = {\r\n  CALL_ACCEPTED: 'CALL_ACCEPTED',\r\n  CALL_REJECTED: 'CALL_REJECTED',\r\n  CALL_NOT_AVAILABLE: 'CALL_NOT_AVAILABLE'\r\n};\r\n\r\nconst defaultConstrains = {\r\n  video: true,\r\n  audio: true\r\n};\r\n\r\nconst configuration = {\r\n  iceServers: [{\r\n    urls: 'stun:stun.l.google.com:13902'\r\n  }]\r\n};\r\n\r\nlet connectedUserSocketId;\r\nlet peerConnection;\r\n\r\nexport const getLocalStream = () => {\r\n  navigator.mediaDevices.getUserMedia(defaultConstrains)\r\n    .then(stream => {\r\n      store.dispatch(setLocalStream(stream));\r\n      store.dispatch(setCallState(callStates.CALL_AVAILABLE));\r\n      createPeerConnection();\r\n    })\r\n    .catch(err => {\r\n      console.log('error occured when trying to get an access to get local stream');\r\n      console.log(err);\r\n    });\r\n}\r\n;\r\n\r\nconst createPeerConnection = () => {\r\n  peerConnection = new RTCPeerConnection(configuration);\r\n\r\n  const localStream = store.getState().call.localStream;\r\n\r\n  for (const track of localStream.getTrack()) {\r\n    peerConnection.addTrack(track, localStream);\r\n  }\r\n\r\n  peerConnection.ontrack = ({ streams: [stream] }) => {\r\n    // dispatch remote stream in our store\r\n  };\r\n\r\n  peerConnection.onicecandidate = (event) => {\r\n    // send to connected user our ice candidates\r\n  };\r\n};\r\n\r\nexport const callToOtherUser = (calleeDetails) => {\r\n  connectedUserSocketId = calleeDetails.socketId;\r\n  store.dispatch(setCallState(callStates.CALL_IN_PROGRESS));\r\n  store.dispatch(setCallingDialogVisible(true));\r\n  wss.sendPreOffer({\r\n    callee: calleeDetails,\r\n    caller: {\r\n      username: store.getState().dashboard.username\r\n    }\r\n  });\r\n};\r\n\r\nexport const handlePreOffer = (data) => {\r\n  if (checkIfCallIsPossible()) {\r\n    connectedUserSocketId = data.callerSocketId;\r\n    store.dispatch(setCallerUsername(data.callerUsername));\r\n    store.dispatch(setCallState(callStates.CALL_REQUESTED));\r\n  } else {\r\n    wss.sendPreOfferAnswer({\r\n      callerSocketId: data.callerSocketId,\r\n      answer: preOfferAnswers.CALL_NOT_AVAILABLE\r\n    });\r\n  }\r\n};\r\n\r\nexport const acceptIncomingCallRequest = () => {\r\n  wss.sendPreOfferAnswer({\r\n    callerSocketId: connectedUserSocketId,\r\n    answer: preOfferAnswers.CALL_ACCEPTED\r\n  });\r\n};\r\n\r\nexport const rejectIncomingCallRequest = () => {\r\n  wss.sendPreOfferAnswer({\r\n    callerSocketId: connectedUserSocketId,\r\n    answer: preOfferAnswers.CALL_REJECTED\r\n  });\r\n  resetCallData();\r\n};\r\n\r\nexport const handlePreOfferAnswer = (data) => {\r\n  store.dispatch(setCallingDialogVisible(false));\r\n\r\n  if (data.answer === preOfferAnswers.CALL_ACCEPTED) {\r\n    // send webRTC offer\r\n  } else {\r\n    let rejectionReason;\r\n    if (data.answer === preOfferAnswers.CALL_NOT_AVAILABLE) {\r\n      rejectionReason = 'Callee is not able to pick up the call right now';\r\n    } else {\r\n      rejectionReason = 'Call rejected by the callee';\r\n    }\r\n    store.dispatch(setCallRejected({\r\n      rejected: true,\r\n      reason: rejectionReason\r\n    }));\r\n\r\n    resetCallData();\r\n  }\r\n};\r\n\r\nexport const checkIfCallIsPossible = () => {\r\n  if (store.getState().call.localStream === null ||\r\n  store.getState().call.callState !== callStates.CALL_AVAILABLE) {\r\n    return false;\r\n  } else {\r\n    return true;\r\n  }\r\n};\r\n\r\nexport const resetCallData = () => {\r\n  connectedUserSocketId = null;\r\n  store.dispatch(setCallState(callStates.CALL_AVAILABLE));\r\n};\r\n"]},"metadata":{},"sourceType":"module"}