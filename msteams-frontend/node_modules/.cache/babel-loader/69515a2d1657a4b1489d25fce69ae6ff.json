{"ast":null,"code":"import store from '../../store/store';\nimport { setLocalStream, setCallState, callStates, setCallingDialogVisible, setCallerUsername, setCallRejected, setRemoteStream, setScreenSharingActive, resetCallDataState, setMessage } from '../../store/actions/callActions';\nimport * as wss from '../wssConnection/wssConnection';\nconst preOfferAnswers = {\n  CALL_ACCEPTED: 'CALL_ACCEPTED',\n  CALL_REJECTED: 'CALL_REJECTED',\n  CALL_NOT_AVAILABLE: 'CALL_NOT_AVAILABLE'\n};\nconst defaultConstrains = {\n  video: {\n    width: 480,\n    height: 360\n  },\n  audio: true\n};\nconst configuration = {\n  iceServers: [{\n    urls: 'stun:stun.l.google.com:13902'\n  }]\n};\nlet connectedUserSocketId;\nlet peerConnection;\nlet dataChannel;\nexport const getLocalStream = () => {\n  navigator.mediaDevices.getUserMedia(defaultConstrains).then(stream => {\n    store.dispatch(setLocalStream(stream));\n    store.dispatch(setCallState(callStates.CALL_AVAILABLE));\n    createPeerConnection();\n  }).catch(err => {\n    console.log('error occured when trying to get an access to get local stream');\n    console.log(err);\n  });\n};\n\nconst createPeerConnection = () => {\n  peerConnection = new RTCPeerConnection(configuration);\n  const localStream = store.getState().call.localStream;\n\n  for (const track of localStream.getTracks()) {\n    peerConnection.addTrack(track, localStream);\n  }\n\n  peerConnection.ontrack = ({\n    streams: [stream]\n  }) => {\n    store.dispatch(setRemoteStream(stream));\n  }; // incoming data channel messages\n\n\n  peerConnection.ondatachannel = event => {\n    const dataChannel = event.channel;\n\n    dataChannel.onopen = () => {\n      console.log('peer connection is ready to receive data channel messages');\n    };\n\n    dataChannel.onmessage = event => {\n      store.dispatch(setMessage(true, event.data));\n    };\n  };\n\n  dataChannel = peerConnection.createDataChannel('chat');\n\n  dataChannel.onopen = () => {\n    console.log('chat data channel succesfully opened');\n  };\n\n  peerConnection.onicecandidate = event => {\n    console.log('geeting candidates from stun server');\n\n    if (event.candidate) {\n      wss.sendWebRTCCandidate({\n        candidate: event.candidate,\n        connectedUserSocketId: connectedUserSocketId\n      });\n    }\n  };\n\n  peerConnection.onconnectionstatechange = event => {\n    if (peerConnection.connectionState === 'connected') {\n      console.log('succesfully connected with other peer');\n    }\n  };\n};\n\nexport const callToOtherUser = calleeDetails => {\n  connectedUserSocketId = calleeDetails.socketId;\n  store.dispatch(setCallState(callStates.CALL_IN_PROGRESS));\n  store.dispatch(setCallingDialogVisible(true));\n  wss.sendPreOffer({\n    callee: calleeDetails,\n    caller: {\n      username: store.getState().dashboard.username\n    }\n  });\n};\nexport const handlePreOffer = data => {\n  if (checkIfCallIsPossible()) {\n    connectedUserSocketId = data.callerSocketId;\n    store.dispatch(setCallerUsername(data.callerUsername));\n    store.dispatch(setCallState(callStates.CALL_REQUESTED));\n  } else {\n    wss.sendPreOfferAnswer({\n      callerSocketId: data.callerSocketId,\n      answer: preOfferAnswers.CALL_NOT_AVAILABLE\n    });\n  }\n};\nexport const acceptIncomingCallRequest = () => {\n  wss.sendPreOfferAnswer({\n    callerSocketId: connectedUserSocketId,\n    answer: preOfferAnswers.CALL_ACCEPTED\n  });\n  store.dispatch(setCallState(callStates.CALL_IN_PROGRESS));\n};\nexport const rejectIncomingCallRequest = () => {\n  wss.sendPreOfferAnswer({\n    callerSocketId: connectedUserSocketId,\n    answer: preOfferAnswers.CALL_REJECTED\n  });\n  resetCallData();\n};\nexport const handlePreOfferAnswer = data => {\n  store.dispatch(setCallingDialogVisible(false));\n\n  if (data.answer === preOfferAnswers.CALL_ACCEPTED) {\n    sendOffer();\n  } else {\n    let rejectionReason;\n\n    if (data.answer === preOfferAnswers.CALL_NOT_AVAILABLE) {\n      rejectionReason = 'Callee is not able to pick up the call right now';\n    } else {\n      rejectionReason = 'Call rejected by the callee';\n    }\n\n    store.dispatch(setCallRejected({\n      rejected: true,\n      reason: rejectionReason\n    }));\n    resetCallData();\n  }\n};\n\nconst sendOffer = async () => {\n  const offer = await peerConnection.createOffer();\n  await peerConnection.setLocalDescription(offer);\n  wss.sendWebRTCOffer({\n    calleeSocketId: connectedUserSocketId,\n    offer: offer\n  });\n};\n\nexport const handleOffer = async data => {\n  await peerConnection.setRemoteDescription(data.offer);\n  const answer = await peerConnection.createAnswer();\n  await peerConnection.setLocalDescription(answer);\n  wss.sendWebRTCAnswer({\n    callerSocketId: connectedUserSocketId,\n    answer: answer\n  });\n};\nexport const handleAnswer = async data => {\n  await peerConnection.setRemoteDescription(data.answer);\n};\nexport const handleCandidate = async data => {\n  try {\n    console.log('adding ice candidates');\n    await peerConnection.addIceCandidate(data.candidate);\n  } catch (err) {\n    console.error('error occured when trying to add received ice candidate', err);\n  }\n};\nexport const checkIfCallIsPossible = () => {\n  if (store.getState().call.localStream === null || store.getState().call.callState !== callStates.CALL_AVAILABLE) {\n    return false;\n  } else {\n    return true;\n  }\n};\nlet screenSharingStream;\nexport const switchForScreenSharingStream = async () => {\n  if (!store.getState().call.screenSharingActive) {\n    try {\n      screenSharingStream = await navigator.mediaDevices.getDisplayMedia({\n        video: true\n      });\n      store.dispatch(setScreenSharingActive(true));\n      const senders = peerConnection.getSenders();\n      const sender = senders.find(sender => sender.track.kind == screenSharingStream.getVideoTracks()[0].kind);\n      sender.replaceTrack(screenSharingStream.getVideoTracks()[0]);\n    } catch (err) {\n      console.error('error occured when trying to get screen sharing stream', err);\n    }\n  } else {\n    const localStream = store.getState().call.localStream;\n    const senders = peerConnection.getSenders();\n    const sender = senders.find(sender => sender.track.kind == localStream.getVideoTracks()[0].kind);\n    sender.replaceTrack(localStream.getVideoTracks()[0]);\n    store.dispatch(setScreenSharingActive(false));\n    screenSharingStream.getTracks().forEach(track => track.stop());\n  }\n};\nexport const handleUserHangedUp = () => {\n  resetCallDataAfterHangUp();\n};\nexport const hangUp = () => {\n  wss.sendUserHangedUp({\n    connectedUserSocketId: connectedUserSocketId\n  });\n  resetCallDataAfterHangUp();\n};\n\nconst resetCallDataAfterHangUp = () => {\n  peerConnection.close();\n  peerConnection = null;\n  createPeerConnection();\n  resetCallData();\n  const localStream = store.getState().call.localStream;\n  localStream.getVideoTracks()[0].enabled = true;\n  localStream.getAudioTracks()[0].enabled = true;\n\n  if (store.getState().call.screenSharingActive) {\n    screenSharingStream.getTracks().forEach(track => {\n      track.stop();\n    });\n  }\n\n  store.dispatch(resetCallDataState());\n};\n\nexport const resetCallData = () => {\n  connectedUserSocketId = null;\n  store.dispatch(setCallState(callStates.CALL_AVAILABLE));\n};\nexport const sendMessageUsingDataChannel = message => {\n  dataChannel.send(message);\n};","map":{"version":3,"sources":["C:/Users/akshi/OneDrive/Documents/Desktop/Microsoft-Clone/msteams/msteams-frontend/src/utils/webRTC/webRTCHandler.js"],"names":["store","setLocalStream","setCallState","callStates","setCallingDialogVisible","setCallerUsername","setCallRejected","setRemoteStream","setScreenSharingActive","resetCallDataState","setMessage","wss","preOfferAnswers","CALL_ACCEPTED","CALL_REJECTED","CALL_NOT_AVAILABLE","defaultConstrains","video","width","height","audio","configuration","iceServers","urls","connectedUserSocketId","peerConnection","dataChannel","getLocalStream","navigator","mediaDevices","getUserMedia","then","stream","dispatch","CALL_AVAILABLE","createPeerConnection","catch","err","console","log","RTCPeerConnection","localStream","getState","call","track","getTracks","addTrack","ontrack","streams","ondatachannel","event","channel","onopen","onmessage","data","createDataChannel","onicecandidate","candidate","sendWebRTCCandidate","onconnectionstatechange","connectionState","callToOtherUser","calleeDetails","socketId","CALL_IN_PROGRESS","sendPreOffer","callee","caller","username","dashboard","handlePreOffer","checkIfCallIsPossible","callerSocketId","callerUsername","CALL_REQUESTED","sendPreOfferAnswer","answer","acceptIncomingCallRequest","rejectIncomingCallRequest","resetCallData","handlePreOfferAnswer","sendOffer","rejectionReason","rejected","reason","offer","createOffer","setLocalDescription","sendWebRTCOffer","calleeSocketId","handleOffer","setRemoteDescription","createAnswer","sendWebRTCAnswer","handleAnswer","handleCandidate","addIceCandidate","error","callState","screenSharingStream","switchForScreenSharingStream","screenSharingActive","getDisplayMedia","senders","getSenders","sender","find","kind","getVideoTracks","replaceTrack","forEach","stop","handleUserHangedUp","resetCallDataAfterHangUp","hangUp","sendUserHangedUp","close","enabled","getAudioTracks","sendMessageUsingDataChannel","message","send"],"mappings":"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","sourcesContent":["import store from '../../store/store';\r\nimport { setLocalStream, setCallState, callStates, setCallingDialogVisible, setCallerUsername, setCallRejected, setRemoteStream, setScreenSharingActive, resetCallDataState, setMessage } from '../../store/actions/callActions';\r\nimport * as wss from '../wssConnection/wssConnection';\r\n\r\nconst preOfferAnswers = {\r\n  CALL_ACCEPTED: 'CALL_ACCEPTED',\r\n  CALL_REJECTED: 'CALL_REJECTED',\r\n  CALL_NOT_AVAILABLE: 'CALL_NOT_AVAILABLE'\r\n};\r\n\r\nconst defaultConstrains = {\r\n  video: {\r\n    width: 480,\r\n    height: 360\r\n  },\r\n  audio: true\r\n};\r\n\r\nconst configuration = {\r\n  iceServers: [{\r\n    urls: 'stun:stun.l.google.com:13902'\r\n  }]\r\n};\r\n\r\nlet connectedUserSocketId;\r\nlet peerConnection;\r\nlet dataChannel;\r\n\r\nexport const getLocalStream = () => {\r\n  navigator.mediaDevices.getUserMedia(defaultConstrains)\r\n    .then(stream => {\r\n      store.dispatch(setLocalStream(stream));\r\n      store.dispatch(setCallState(callStates.CALL_AVAILABLE));\r\n      createPeerConnection();\r\n    })\r\n    .catch(err => {\r\n      console.log('error occured when trying to get an access to get local stream');\r\n      console.log(err);\r\n    });\r\n}\r\n;\r\n\r\nconst createPeerConnection = () => {\r\n  peerConnection = new RTCPeerConnection(configuration);\r\n\r\n  const localStream = store.getState().call.localStream;\r\n\r\n  for (const track of localStream.getTracks()) {\r\n    peerConnection.addTrack(track, localStream);\r\n  }\r\n\r\n  peerConnection.ontrack = ({ streams: [stream] }) => {\r\n    store.dispatch(setRemoteStream(stream));\r\n  };\r\n\r\n  // incoming data channel messages\r\n  peerConnection.ondatachannel = (event) => {\r\n    const dataChannel = event.channel;\r\n\r\n    dataChannel.onopen = () => {\r\n      console.log('peer connection is ready to receive data channel messages');\r\n    };\r\n\r\n    dataChannel.onmessage = (event) => {\r\n      store.dispatch(setMessage(true, event.data));\r\n    };\r\n  };\r\n\r\n  dataChannel = peerConnection.createDataChannel('chat');\r\n\r\n  dataChannel.onopen = () => {\r\n    console.log('chat data channel succesfully opened');\r\n  };\r\n\r\n  peerConnection.onicecandidate = (event) => {\r\n    console.log('geeting candidates from stun server');\r\n    if (event.candidate) {\r\n      wss.sendWebRTCCandidate({\r\n        candidate: event.candidate,\r\n        connectedUserSocketId: connectedUserSocketId\r\n      });\r\n    }\r\n  };\r\n\r\n  peerConnection.onconnectionstatechange = (event) => {\r\n    if (peerConnection.connectionState === 'connected') {\r\n      console.log('succesfully connected with other peer');\r\n    }\r\n  };\r\n};\r\n\r\nexport const callToOtherUser = (calleeDetails) => {\r\n  connectedUserSocketId = calleeDetails.socketId;\r\n  store.dispatch(setCallState(callStates.CALL_IN_PROGRESS));\r\n  store.dispatch(setCallingDialogVisible(true));\r\n  wss.sendPreOffer({\r\n    callee: calleeDetails,\r\n    caller: {\r\n      username: store.getState().dashboard.username\r\n    }\r\n  });\r\n};\r\n\r\nexport const handlePreOffer = (data) => {\r\n  if (checkIfCallIsPossible()) {\r\n    connectedUserSocketId = data.callerSocketId;\r\n    store.dispatch(setCallerUsername(data.callerUsername));\r\n    store.dispatch(setCallState(callStates.CALL_REQUESTED));\r\n  } else {\r\n    wss.sendPreOfferAnswer({\r\n      callerSocketId: data.callerSocketId,\r\n      answer: preOfferAnswers.CALL_NOT_AVAILABLE\r\n    });\r\n  }\r\n};\r\n\r\nexport const acceptIncomingCallRequest = () => {\r\n  wss.sendPreOfferAnswer({\r\n    callerSocketId: connectedUserSocketId,\r\n    answer: preOfferAnswers.CALL_ACCEPTED\r\n  });\r\n\r\n  store.dispatch(setCallState(callStates.CALL_IN_PROGRESS));\r\n};\r\n\r\nexport const rejectIncomingCallRequest = () => {\r\n  wss.sendPreOfferAnswer({\r\n    callerSocketId: connectedUserSocketId,\r\n    answer: preOfferAnswers.CALL_REJECTED\r\n  });\r\n  resetCallData();\r\n};\r\n\r\nexport const handlePreOfferAnswer = (data) => {\r\n  store.dispatch(setCallingDialogVisible(false));\r\n\r\n  if (data.answer === preOfferAnswers.CALL_ACCEPTED) {\r\n    sendOffer();\r\n  } else {\r\n    let rejectionReason;\r\n    if (data.answer === preOfferAnswers.CALL_NOT_AVAILABLE) {\r\n      rejectionReason = 'Callee is not able to pick up the call right now';\r\n    } else {\r\n      rejectionReason = 'Call rejected by the callee';\r\n    }\r\n    store.dispatch(setCallRejected({\r\n      rejected: true,\r\n      reason: rejectionReason\r\n    }));\r\n\r\n    resetCallData();\r\n  }\r\n};\r\n\r\nconst sendOffer = async () => {\r\n  const offer = await peerConnection.createOffer();\r\n  await peerConnection.setLocalDescription(offer);\r\n  wss.sendWebRTCOffer({\r\n    calleeSocketId: connectedUserSocketId,\r\n    offer: offer\r\n  });\r\n};\r\n\r\nexport const handleOffer = async (data) => {\r\n  await peerConnection.setRemoteDescription(data.offer);\r\n  const answer = await peerConnection.createAnswer();\r\n  await peerConnection.setLocalDescription(answer);\r\n  wss.sendWebRTCAnswer({\r\n    callerSocketId: connectedUserSocketId,\r\n    answer: answer\r\n  });\r\n};\r\n\r\nexport const handleAnswer = async (data) => {\r\n  await peerConnection.setRemoteDescription(data.answer);\r\n};\r\n\r\nexport const handleCandidate = async (data) => {\r\n  try {\r\n    console.log('adding ice candidates');\r\n    await peerConnection.addIceCandidate(data.candidate);\r\n  } catch (err) {\r\n    console.error('error occured when trying to add received ice candidate', err);\r\n  }\r\n};\r\n\r\nexport const checkIfCallIsPossible = () => {\r\n  if (store.getState().call.localStream === null ||\r\n  store.getState().call.callState !== callStates.CALL_AVAILABLE) {\r\n    return false;\r\n  } else {\r\n    return true;\r\n  }\r\n};\r\n\r\nlet screenSharingStream;\r\n\r\nexport const switchForScreenSharingStream = async () => {\r\n  if (!store.getState().call.screenSharingActive) {\r\n    try {\r\n      screenSharingStream = await navigator.mediaDevices.getDisplayMedia({ video: true });\r\n      store.dispatch(setScreenSharingActive(true));\r\n      const senders = peerConnection.getSenders();\r\n      const sender = senders.find(sender => sender.track.kind == screenSharingStream.getVideoTracks()[0].kind);\r\n      sender.replaceTrack(screenSharingStream.getVideoTracks()[0]);\r\n    } catch (err) {\r\n      console.error('error occured when trying to get screen sharing stream', err);\r\n    }\r\n  } else {\r\n    const localStream = store.getState().call.localStream;\r\n    const senders = peerConnection.getSenders();\r\n    const sender = senders.find(sender => sender.track.kind == localStream.getVideoTracks()[0].kind);\r\n    sender.replaceTrack(localStream.getVideoTracks()[0]);\r\n    store.dispatch(setScreenSharingActive(false));\r\n    screenSharingStream.getTracks().forEach(track => track.stop());\r\n  }\r\n}\r\n;\r\n\r\nexport const handleUserHangedUp = () => {\r\n  resetCallDataAfterHangUp();\r\n};\r\n\r\nexport const hangUp = () => {\r\n  wss.sendUserHangedUp({\r\n    connectedUserSocketId: connectedUserSocketId\r\n  });\r\n\r\n  resetCallDataAfterHangUp();\r\n};\r\n\r\nconst resetCallDataAfterHangUp = () => {\r\n  peerConnection.close();\r\n  peerConnection = null;\r\n  createPeerConnection();\r\n  resetCallData();\r\n\r\n  const localStream = store.getState().call.localStream;\r\n  localStream.getVideoTracks()[0].enabled = true;\r\n  localStream.getAudioTracks()[0].enabled = true;\r\n\r\n  if (store.getState().call.screenSharingActive) {\r\n    screenSharingStream.getTracks().forEach(track => {\r\n      track.stop();\r\n    });\r\n  }\r\n\r\n  store.dispatch(resetCallDataState());\r\n};\r\n\r\nexport const resetCallData = () => {\r\n  connectedUserSocketId = null;\r\n  store.dispatch(setCallState(callStates.CALL_AVAILABLE));\r\n};\r\n\r\nexport const sendMessageUsingDataChannel = (message) => {\r\n  dataChannel.send(message);\r\n}\r\n;\r\n"]},"metadata":{},"sourceType":"module"}